#+title:Yasper's Emacs Init
#+author: Yasper De Jong
#+property: header-args:emacs-lisp :tangle init.el
#+startup: overview

* Package Management

Add Melpa as a source for packages, and define a version of =require= that installs a package if it is missing.

#+begin_src emacs-lisp
	(require 'package)
	(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

	(defun ysd-require (package &optional min-version no-refresh)
	  "Ask elpa to install given PACKAGE with MIN-VERSION.
	If NO-REFRESH is nil, `package-refresh-contents' is called."
	  (unless (package-installed-p package min-version)
		(message "Missing package: %s" package)
		(unless (or (assoc package package-archive-contents) no-refresh)
	  (package-refresh-contents))
		(package-install package)
		(push package 'package-selected-packages))
	  (require package))
#+end_src

Load environment variables
#+begin_src emacs-lisp
  (load "~/.emacs.d/env.el")
#+end_Src

* Custom Functions
** Kill and Copy
More convenient copy and kill functions

#+begin_src emacs-lisp
  (defun ysd-kill-region-or-line (&optional beg end)
	"Kill region if active, otherwise, kill whole line."
	(interactive (if (use-region-p) (list (region-beginning) (region-end))))
	(if (use-region-p)
	(kill-region beg end)
	  (kill-whole-line)))

  (defun ysd-copy-region-or-line (&optional beg end)
	"Copy region if active, otherwise, copy whole line."
	(interactive (if (use-region-p) (list (region-beginning) (region-end))))
	(if (use-region-p) ;; If there is a region
	(copy-region-as-kill beg end)
	  (copy-region-as-kill (line-beginning-position)
			   (line-beginning-position 2))))
#+end_src

** Improved Yank
Yanking multiple times cycles through the kill ring.

#+begin_src emacs-lisp
  (defun ysd-yank ()
    "Yank or cycle through the kill ring."
    (interactive "*")
    (if (eq last-command 'yank)
	(yank-pop)
      (setq kill-ring-yank-pointer kill-ring)
      (yank)))
#+end_src

** Utility
Used for conditional keybindings in overlapping modes

#+begin_src emacs-lisp
  (defmacro define-key-with-fallback (keymap key def condition &optional mode)
	"Define key with fallback. Binds KEY to definition DEF in keymap KEYMAP, 
	 the binding is active when the CONDITION is true. Otherwise turns MODE off 
	 and re-enables previous definition for KEY. If MODE is nil, tries to recover 
	 it by stripping off \"-map\" from KEYMAP name."
	`(define-key ,keymap ,key
	   (lambda () (interactive)
		  (if ,condition ,def
			(let* ((,(if mode mode
					   (let* ((keymap-str (symbol-name keymap))
							  (mode-name-end (- (string-width keymap-str) 4)))
						 (if (string= "-map" (substring keymap-str mode-name-end))
							 (intern (substring keymap-str 0 mode-name-end))
						   (error "Could not deduce mode name from keymap name (\"-map\" missing?)")))) 
					nil)
				   (original-func (key-binding ,key)))
			  (call-interactively original-func))))))
#+end_src

* Modal
Custom modal setup

#+begin_src emacs-lisp
  (ysd-require 'ryo-modal)

  (define-key ryo-modal-mode-map [remap self-insert-command] 'ignore) ;; Make all letters/etc. do nothing

  (global-set-key (kbd "<f1>") 'ryo-modal-mode)

  (ryo-modal-keys
   ("i" previous-line)
   ("k" next-line)
   ("j" backward-char)
   ("l" forward-char)
   ("u" backward-word)
   ("o" forward-word)
   ("I" scroll-down-line)
   ("K" scroll-up-line)
   ("J" move-beginning-of-line)
   ("L" move-end-of-line)
   ("U" beginning-of-buffer)
   ("O" end-of-buffer)
   ("r" query-replace)
   ("x" ysd-kill-region-or-line)
   ("c" ysd-copy-region-or-line)
   ("y" ysd-yank)
   ("z" undo)
   ("Z" undo-redo)
   ("g" goto-map)
   (";" comment-line)
   ("SPC" set-mark-command))

  (global-set-key (kbd "C-<tab>") 'other-window) ;; TODO Adapt for terminal interface

  (setq ryo-excluded-modes
	'(eshell-mode dired-mode treemacs-mode vterm-mode inferior-python-mode))

  (add-hook 'window-selection-change-functions
		(lambda (buf) (interactive)
		  (unless (or (minibufferp (window-buffer (old-selected-window)))
			  (minibufferp (current-buffer))
			  (member major-mode ryo-excluded-modes))
		(ryo-modal-mode 1))))


  (define-globalized-minor-mode ryo-modal-global-mode
	ryo-modal-mode
	(lambda () (unless (or (minibufferp)
			   (member major-mode ryo-excluded-modes))
		 (ryo-modal-mode 1))))

  (ryo-modal-global-mode 1)
#+end_src

** General Keybinds
Generaly keybinds that are not necessarily part of the RYO map

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s") 'save-buffer)
  (global-set-key (kbd "C-r") 'revert-buffer)
#+end_src

** Which Key
Make which key commands attached to "?" that show binds for the major mode, ryo modal itself, or everything accessible at the moment (excluding ryo bindings)
I want to make which key as constantly accessible as possible, i.e. focus on recoginition over recall

#+begin_src emacs-lisp
  (ysd-require 'which-key)
  (which-key-setup-side-window-right)
  (setq which-key-idle-delay 0.4
		which-key-use-C-h-commands t)

  (defun ysd-which-key-show-top-level-excluding-ryo ()
	(interactive)
	(let ((ryo-modal-mode nil))
	  (which-key-show-top-level)))
  (ryo-modal-key "?" 'ysd-which-key-show-top-level-excluding-ryo)

  ; Workaround for a paging key that has another keybind attached in underlying modes
  (defun ysd-which-key-maybe-C-h-dispatch ()
	(interactive)
	(if (which-key--popup-showing-p) (which-key-C-h-dispatch)
	  (let ((which-key-mode nil))
		(command-execute (key-binding "?")))))
  (push 'ysd-which-key-maybe-C-h-dispatch which-key--paging-functions)
  (keymap-set which-key-mode-map "?" 'ysd-which-key-maybe-C-h-dispatch)

  ; Paging keys that match the rest of the config
  (keymap-set which-key-C-h-map "k" 'which-key-show-next-page-cycle)
  (keymap-set which-key-C-h-map "i" 'which-key-show-previous-page-cycle)
  (which-key-mode 1)
#+end_src

* Ivy/Counsel
Use Ivy/Counsel for completion, and replace many functions such as find file and search

** Assign keybinds
Rebind some basic commands to their counsel equivalents, and use IJKL bindings for navigating the minibuffer

#+begin_src emacs-lisp
  (ysd-require 'counsel)
  (ivy-mode 1)

  (global-set-key (kbd "C-f") 'counsel-find-file)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-b") 'ivy-switch-buffer)

  ;; Minibuffer bindings
  (ivy-define-key ivy-minibuffer-map (kbd "<tab>") 'ivy-partial-or-done) ;; Workaround since C-i and TAB are the same, but <tab> is different
  (ivy-define-key ivy-minibuffer-map (kbd "C-i") 'ivy-previous-line)
  (ivy-define-key ivy-minibuffer-map (kbd "C-k") 'ivy-next-line)
  (ivy-define-key ivy-minibuffer-map (kbd "C-u") 'ivy-beginning-of-buffer)
  (ivy-define-key ivy-minibuffer-map (kbd "C-o") 'ivy-end-of-buffer)

  ;; Switch buffer bindings
  (ivy-define-key ivy-switch-buffer-map (kbd "C-k") 'ivy-next-line)
  (ivy-define-key ivy-switch-buffer-map (kbd "C-d") 'ivy-switch-buffer-kill)

#+end_src

** Resize Minibuffer
Add bindings to resize the minibuffer to show more/fewer results

#+begin_src emacs-lisp

  (defun ysd-ivy-minibuffer-grow ()
	(interactive)
	(setq-local max-mini-window-height
				(cl-incf ivy-height)))

  (defun ysd-ivy-minibuffer-shrink ()
	(interactive)
	(when (> ivy-height 2)
	(setq-local max-mini-window-height
				(cl-decf ivy-height))
	(window-resize nil -1)))

  (ivy-define-key ivy-minibuffer-map (kbd "M-I")
		  'ysd-ivy-minibuffer-grow)
  (ivy-define-key ivy-minibuffer-map (kbd "M-K")
		  'ysd-ivy-minibuffer-shrink)

  (define-key swiper-map (kbd "C-r") 'swiper-query-replace)
#+end_src

** Swiper DWIM
Swiper, which uses the current region as the search term if it is active

#+begin_src emacs-lisp
  (defun ysd-swiper-dwim (&optional beg end)
	(interactive (if (use-region-p) (list (region-beginning) (region-end))))
	(if (use-region-p)
		(swiper (buffer-substring beg end))
	  (call-interactively 'swiper)))
  (ryo-modal-key "s" 'ysd-swiper-dwim)
  (ryo-modal-key "S" 'swiper-thing-at-point)
#+end_src

** Misc
#+begin_src emacs-lisp
  (add-to-list 'ivy-initial-inputs-alist '(counsel-M-x . ""))
#+end_src

* Visuals
** Theme
I use Catppuccin's [[https://github.com/catppuccin/emacs][Catppuccin for Emacs]] Macchiato theme.
Catppuccin offers their themes for several apps and services, including [[https://hyprland.org/][Hyprland]], my current desktop environment. This allows me to have consistent theming across my system.

#+begin_src emacs-lisp
  (require 'url)
  (let ((theme-path (file-name-as-directory (locate-user-emacs-file "themes"))))

    ;; Download theme file from GitHub if it does not exist
    (unless
	(file-exists-p (concat theme-path "catppuccin-theme.el"))
      (url-copy-file "https://raw.githubusercontent.com/catppuccin/emacs/main/catppuccin-theme.el" (concat theme-path "catppuccin-theme.el")))

    ;; load theme
    (add-to-list 'custom-theme-load-path theme-path)
    (setq catppuccin-flavor 'macchiato)
    (load-theme 'catppuccin t))
#+end_src

*** Extra Changes
Change a couple more things, based on the Catppuccin theme

#+begin_src emacs-lisp
  (set-face-attribute 'trailing-whitespace nil :background (catppuccin-get-color 'maroon))
#+end_src

** Fonts
TODO: Create custom vars for default face, title face, and variable-width/mono face, and then assign them with =set-face-attribute= in init.el
TODO: Auto download/install(?) fonts if not installed already

** Text and Cursor Styling
Display line numbers, use thin cursor (TODO: change cursor color with modal)

#+begin_src emacs-lisp
  (setq-default
   cursor-type '(bar . 2)
   truncate-lines t)

  (setq ryo-modal-default-cursor-color (face-attribute 'cursor :background)
	ryo-modal-cursor-type '(bar . 2)
	ryo-modal-cursor-color (catppuccin-get-color 'text))

  (global-display-line-numbers-mode 1)

  (dolist (mode '(org-mode-hook
		  fundamental-mode-hook
		  help-mode-hook))

    (add-hook mode (lambda ()
		     (display-line-numbers-mode 0)
		     (setq truncate-lines nil)
		     (visual-line-mode 1))))
#+end_src

** Telephone Line
I prefer having status information, etc. on the header line instead of the mode line because it distributes information across the screen rather than compressing completions, modeline, minibuffer, etc. to the bottom of the screen.

Use =telephone-line= to create the header line

#+begin_src emacs-lisp
	(ysd-require 'telephone-line)

	(defun ysd-make-header-line-mouse-map (mouse function)
	  (let ((map (make-sparse-keymap)))
		(define-key map (vector 'header-line mouse) function)
		map))
#+end_src

*** Faces
Define faces for background and color changing text based on states

#+begin_src emacs-lisp
  ;;(set-face-attribute 'mode-line nil :background (catppuccin-get-color 'overlay1))
  (set-face-attribute 'telephone-line-evil-normal nil :foreground (catppuccin-get-color 'red) :background (catppuccin-get-color 'base))
  (set-face-attribute 'telephone-line-evil-insert nil :foreground (catppuccin-get-color 'green) :background (catppuccin-get-color 'base))

  (defface ysd-tele-line-modified
	`((t (:foreground ,(catppuccin-get-color 'red) :background ,(catppuccin-get-color 'surface2))))
	"Telephone line modified face"
	:group 'telephone-line)

  (defface ysd-surface2-bg
	`((t (:background ,(catppuccin-get-color 'surface2))))
	"Surface2 background face"
	:group 'telephone-line)

  (defface ysd-surface1-bg
	`((t :background ,(catppuccin-get-color 'surface1)))
	"Surface1 background face"
	:group 'telephone-line)

  (defface ysd-invisible
	`((t (:foreground ,(catppuccin-get-color 'base) :background ,(catppuccin-get-color 'base))))
	"Surface1 background face"
	:group 'telephone-line)

  (defun ysd-tele-line-surface1-face (active)
	(cond ((not active) 'mode-line-inactive)
		  (t 'ysd-surface1-bg)))

  (defun ysd-tele-line-surface2-face (active)
	(cond ((not active) 'mode-line-inactive)
		  (t 'ysd-surface2-bg)))


  (defun ysd-tele-line-buffer-face (active)
	'ysd-invisible)

  (telephone-line-defsegment* ysd-buffer-segment ()
	" ")

  (push '(surface2 . ysd-tele-line-surface2-face) telephone-line-faces)
  (push '(surface1 . ysd-tele-line-surface1-face) telephone-line-faces)
  (push '(buffer . ysd-tele-line-buffer-face) telephone-line-faces)
#+end_src

*** RYO Segment and Buffer Name Segment
Custom segment to show insert/command mode using an indicator light, mildly inspired by doom mode line

#+begin_src emacs-lisp
  (defun ysd-tele-line-modified-face (active)
	(cond ((not active) 'mode-line-inactive)
		  ((buffer-modified-p) 'ysd-tele-line-modified)
		  (t 'ysd-surface2-bg)))
  (push '(modif . ysd-tele-line-modified-face) telephone-line-faces)

  (defun ysd-modal-face (active)
	"Return an appropriate face depending whether ryo-modal is activated, given whether frame is ACTIVE."
	(cond ((not active) 'ysd-invisible)
		  ((not (boundp 'ryo-modal-mode)) 'mode-line)
		  ((not ryo-modal-mode) 'telephone-line-evil-insert)
		  (t 'telephone-line-evil-normal)))
  (push '(ysd-modal . ysd-modal-face) telephone-line-faces)

  (telephone-line-defsegment* ysd-ryo-modal-segment ()
	"◉")
#+end_src

*** Encoding and EOL Segments
Custom segments that shows the encoding segment of the current document, and changes the encoding when clicked (using set-buffer-file-coding-system)
The EOL segment cycles through different end-of-line-styles on click

#+begin_src emacs-lisp
  (defun ysd-set-coding-system (e)
	(interactive "e")
	(with-selected-window (posn-window (event-start e))
	  (call-interactively 'set-buffer-file-coding-system)))

  (telephone-line-defsegment* ysd-telephone-line-encoding-segment ()
	(propertize
	 (upcase (symbol-name
			  (plist-get (coding-system-plist buffer-file-coding-system) :name)))
	 'help-echo "Buffer coding system:\nmouse-1: Change"
	 'local-map (ysd-make-header-line-mouse-map
				 'mouse-1 (lambda (e)
							(interactive "e")
							(with-selected-window (posn-window (event-start e))
							  (call-interactively 'set-buffer-file-coding-system))))
	 'mouse-face 'mode-line-highlight))


  (telephone-line-defsegment* ysd-telephone-line-eol-segment ()
	(propertize
	 (pcase (coding-system-eol-type buffer-file-coding-system)
	   (0 "LF")
	   (1 "CRLF")
	   (2 "CR"))
	 'help-echo "End-of-line style:\nmouse-1: Cycle"
	 'local-map (ysd-make-header-line-mouse-map
				 'mouse-1 'mode-line-change-eol)
	 'mouse-face 'mode-line-highlight))
#+end_src

*** Half Circle Separator
Custom separator that uses a half circle function to create rounded edges

#+begin_src emacs-lisp
  ;; Circle separator
  (defvar telephone-line-halfcircle-right
	(make-instance 'telephone-line-separator
				   :axis-func (lambda (x) (let ((result (sqrt (- 9.869 (expt x 2)))))
											(if (isnan result) 0 result)))
				   :alt-separator telephone-line-utf-abs-right))

  (defvar telephone-line-halfcircle-left
	(make-instance 'telephone-line-separator
				   :axis-func (lambda (x) (let ((result (- (sqrt (- 9.869 (expt x 2))))))
											(if (isnan result) 0 result)))
				   :alt-separator telephone-line-utf-abs-left))

  (defvar telephone-line-halfcircle-hollow-right
	(make-instance 'telephone-line-subseparator
				   :axis-func (lambda (x) (let ((result (sqrt (- 9.869 (expt x 2)))))
											(if (isnan result) 0 result)))
				   :alt-separator telephone-line-utf-abs-hollow-right))

  (defvar telephone-line-halfcircle-hollow-left
	(make-instance 'telephone-line-subseparator
				   :axis-func (lambda (x) (let ((result (- (sqrt (- 9.869 (expt x 2))))))
											(if (isnan result) 0 result)))
				   :alt-separator telephone-line-utf-abs-hollow-left))
#+end_src

*** Final Config
Activate telephone-line with the header line as the target.
If another process uses the header line, put that information on the mode line instead

#+begin_src emacs-lisp
  (setq
   telephone-line-lhs
   '((ysd-modal . (ysd-ryo-modal-segment))
	 (modif . (telephone-line-buffer-name-segment))
	 (surface1 . (telephone-line-major-mode-segment
				  telephone-line-minor-mode-segment)))
   telephone-line-rhs
   '((surface1 . (ysd-telephone-line-encoding-segment))
	 (surface2 . (ysd-telephone-line-eol-segment))
	 (buffer . (ysd-buffer-segment)))

   telephone-line-target 'header-line ;; TODO disable header-line option in Emacs <28
   telephone-line-primary-left-separator telephone-line-halfcircle-left
   telephone-line-primary-right-separator telephone-line-halfcircle-right)

  (setq-default mode-line-format nil)
  (telephone-line-mode 1)

  (defun swap-header-and-mode-line (symbol newval operation where)
	(with-current-buffer where
	  (when (and (eq operation 'set) (not (eq newval (default-value 'header-line-format))))
		(setq mode-line-format newval)
		(run-with-timer 0 nil (lambda () (setq header-line-format (default-value 'header-line-format)))))))
  ;; run-with-timer 0 waits until after function ends to change header-line-format back to the original value

  (add-variable-watcher 'header-line-format 'swap-header-and-mode-line)
#+end_src

** Diminish Modes
Diminish certain modes so they don't take up space on the header line

#+begin_src emacs-lisp
  (ysd-require 'diminish)
  (let ((diminished-modes
		 '(ivy-mode ryo-modal-mode which-key-mode)))
	(dolist (mode diminished-modes)
	  (diminish mode)))
#+end_src

* Development
** Project Management
*** Projectile
Use projectile to manage projects

#+begin_src emacs-lisp
  (ysd-require 'projectile)
  (ysd-require 'counsel-projectile)
  (define-key projectile-mode-map (kbd "C-p") projectile-command-map)
  (setq projectile-switch-project-action #'projectile-dired)
  (projectile-mode 1)
  (counsel-projectile-mode 1)
#+end_src

*** Treemacs
#+begin_src emacs-lisp
  (ysd-require 'treemacs)
  (ysd-require 'treemacs-projectile)
  (define-key treemacs-mode-map (kbd "i") 'treemacs-previous-line)
  (define-key treemacs-mode-map (kbd "k") 'treemacs-next-line)

  (global-set-key (kbd "C-e") 'treemacs)
#+end_src

** Autocomplete (Company)
#+begin_src emacs-lisp
  (ysd-require 'company)
  (keymap-set company-active-map "C-k" 'company-select-next-or-abort)
  (keymap-set company-active-map "C-k" 'company-select-previous-or-abort)
  (keymap-set company-active-map "C-k" 'company-select-next-or-abort)
  (keymap-set company-active-map "C-i" 'company-select-previous-or-abort)
#+end_src

** Miscellaneous
Random general development settings

TODO: Better indents

#+begin_src emacs-lisp
  (setq-default
   tab-width 4)
#+end_src

** Tree Sitter
Automatically install the collection of pre-compiled tree sitter grammars from github

#+begin_src emacs-lisp
  (require 'url)
  (let ((tree-sitter-dir (file-name-as-directory (locate-user-emacs-file "tree-sitter"))))
	(unless (file-exists-p tree-sitter-dir)
	  (make-directory tree-sitter-dir)
	  (url-copy-file
	   "https://github.com/emacs-tree-sitter/tree-sitter-langs/releases/download/0.12.224/tree-sitter-grammars.x86_64-unknown-linux-gnu.v0.12.224.tar.gz"
	   (concat tree-sitter-dir "tree-sitter-grammars.tar.gz"))
	  (shell-command (concat "tar xzf " (concat tree-sitter-dir "tree-sitter-grammars.tar.gz") " -C " tree-sitter-dir))
  ;; Rename *.so to libtree-sitter-*.so
  (dolist (file (directory-files tree-sitter-dir t "\\.so$"))
	(rename-file file (concat tree-sitter-dir "libtree-sitter-" (file-name-nondirectory file))))))
#+end_src

Map existing major modes to their ts-mode counterparts

#+begin_src emacs-lisp
  (setq major-mode-remap-alist
		'((c-or-c++mode . c-or-c++-ts-mode)
		  (c-mode . c-ts-mode)
		  (c++-mode . c++-ts-mode)
		  (python-mode . python-ts-mode)))
#+end_src

** Folding
Setup code folding with origami. Add a few functions that make it easier to fold all blocks at the same level, e.g. all functions in a class or all classes in a file.

TODO: Use tree-sitter

#+begin_src emacs-lisp
  (ysd-require 'origami)

  (defun ysd-origami-close-all-top-level-nodes (buffer)
	(interactive (list (current-buffer)))
	(-when-let (tree (origami-get-fold-tree buffer))
	  (origami-apply-new-tree
	   buffer tree (origami-store-cached-tree
					buffer
					(origami-fold-children-set
					 tree
					 (-map (lambda (node) (origami-fold-open-set node nil))
						   (origami-fold-children tree)))))))

  (defun ysd-origami-open-all-top-level-nodes (buffer)
	(interactive (list (current-buffer)))
	(-when-let (tree (origami-get-fold-tree buffer))
	  (origami-apply-new-tree
	   buffer tree (origami-store-cached-tree
					buffer
					(origami-fold-children-set
					 tree
					 (-map (lambda (node) (origami-fold-open-set node t))
						   (origami-fold-children tree)))))))

  (defun ysd-origami-close-children (buffer point)
	(interactive (list (current-buffer) (point)))
	(when-let ((tree (origami-get-fold-tree buffer))
			   (path (origami-fold-find-path-containing tree point)))
		(origami-apply-new-tree
		 buffer tree (origami-store-cached-tree
					  buffer
					  (origami-fold-assoc
					   path
					   (lambda (parent)
						 (origami-fold-children-set
						  parent
						  (-map (lambda (node) (origami-fold-open-set node nil))
								(origami-fold-children parent)))))))))

  (defun ysd-origami-open-children (buffer point)
	(interactive (list (current-buffer) (point)))
	(when-let ((tree (origami-get-fold-tree buffer))
			   (path (origami-fold-find-path-containing tree point)))
		(origami-apply-new-tree
		 buffer tree (origami-store-cached-tree
					  buffer
					  (origami-fold-assoc
					   path
					   (lambda (parent)
						 (origami-fold-children-set
						  parent
						  (-map (lambda (node) (origami-fold-open-set node t))
								(origami-fold-children parent)))))))))

  (add-hook 'origami-mode
		(lambda ()
		  (ryo-modal-key "v" 'origami-toggle-node)))
#+end_src

TODO: Create a general development setup function that is hooked to all development modes, includes basic setup for company, electric pair, eglot? treemacs, others

** Typescript
Use =tide= as the typescript server

#+begin_src emacs-lisp
  (ysd-require 'typescript-mode)
  (ysd-require 'tide)
  (ysd-require 'flycheck)
  (ysd-require 'company)
  (ysd-require 'prettier-js)

  (defun setup-typescript-mode ()
	(interactive)

	;;Tide setup
	(tide-setup)
	(flycheck-mode 1)
	(setq flycheck-check-syntax-automatically '(save mode-enabled))
	(eldoc-mode 1)
	(tide-hl-identifier-mode 1)
	(company-mode 1)
	(electric-pair-mode 1)
	(origami-mode 1)
	(indent-tabs-mode -1)

	(setq
	 typescript-indent-level tab-width
	 js-indent-level 2))

  (add-hook 'typescript-mode-hook #'setup-typescript-mode)
  ;;(add-hook 'typescript-mode-hook 'prettier-js-mode)

  (add-hook 'js-mode-hook #'setup-typescript-mode)
  ;;(add-hook 'js-mode-hook 'prettier-js-mode)

#+end_src

** C/C++

Need to resolve the debate over eglot vs lsp-mode, main thing affecting my decision right now is the ability to use flycheck. Eglot uses flymake by default and needs another package + global minor mode to use flycheck instead, while lsp-mode uses flycheck by default. However, eglot will be built-in to emacs soon. 

#+begin_src emacs-lisp
  (ysd-require 'flycheck)
  (ysd-require 'eglot)

  (setq-default
   c-ts-indent-offset tab-width
   c-indentation-style "linux") ;; THis seems to be overwritten when the mode loads

  (ryo-modal-major-mode-keys
   'c++-mode
   ("v" origami-toggle-node)
   ("V"
	(("i" ysd-origami-close-children)
	 ("k" ysd-origami-open-children)
	 ("I" ysd-origami-close-all-top-level-nodes)
	 ("K" ysd-origami-open-all-top-level-nodes))))

  (ryo-modal-major-mode-keys
   'c-mode
   ("v" origami-toggle-node)
   ("V"
	(("i" ysd-origami-close-children)
	 ("k" ysd-origami-open-children)
	 ("I" ysd-origami-close-all-top-level-nodes)
	 ("K" ysd-origami-open-all-top-level-nodes))))

  (push (cons '(c-mode c-ts-mode c++-mode c++-ts-mode) ;; Use ccls over clangd
			  (eglot-alternatives
			   '("ccls" "clangd")))
		eglot-server-programs)

  (defun setup-c++-mode ()
	(interactive)
	(setq
	 c-basic-offset tab-width
	 c-ts-indent-offset tab-width
	 c-indentation-style "linux")
	(electric-pair-mode 1)
	(company-mode 1)
	(eglot-ensure))

  (add-hook 'c++-ts-mode-hook 'setup-c++-mode)
  (add-hook 'c++-mode-hook 'setup-c++-mode)
  (add-hook 'c-mode-hook 'setup-c++-mode)
#+end_src

** Terminal
Use vterm
#+begin_src emacs-lisp
  (ysd-require 'vterm)
  (define-key vterm-mode-map (kbd "<f1>") nil)
  (define-key vterm-mode-map (kbd "C-c <f1>") 'vterm--self-insert)
  (define-key vterm-mode-map (kbd "C-b") nil)
  (define-key vterm-mode-map (kbd "C-c C-b") 'vterm--self-insert)
#+end_src

** Dired

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (keymap-set dired-mode-map "i" 'dired-previous-line)
  (keymap-set dired-mode-map "k" 'dired-next-line)
  (keymap-set dired-mode-map "?" 'which-key-show-top-level)
  (keymap-set dired-mode-map "m" 'dired-do-rename)
  (keymap-set dired-mode-map "c" 'dired-do-copy)
#+end_src

* Miscellaneous

** LLM
Use Groq and the LLM library to provide basic interactions with a chatbot for code generation

#+begin_src emacs-lisp

  ;; Set up llm package
  (ysd-require 'llm)
  (require 'llm-openai)
  (setq llm-warn-on-nonfree nil
		llm-provider-groq (make-llm-openai-compatible
						   :url "https://api.groq.com/openai/v1"
						   :key groq-api-key
						   :chat-model "llama-3.3-70b-versatile"))

  (defun remove-first-and-last-line (str)
	"Remove the first and last lines of the given string STR."
	(let ((lines (split-string str "\n" t)))
	  (when ( > (length lines) 2)
		(mapconcat 'identity (cdr (butlast lines)) "\n"))))

  (defun ysd-llm-generate-code ()
	(interactive)
	(let* ((start (if (use-region-p) (region-beginning) (line-beginning-position)))
		  (end (if (use-region-p) (region-end) (line-end-position)))
		  (prompt (string-trim (buffer-substring start end))))
	  (if (string= prompt "")
		  (setq prompt (read-string "Enter Prompt: "))
		(delete-region start end))
	  (insert (llm-chat
			   llm-provider-groq
			   (llm-make-chat-prompt prompt :context "Respond with only code")))))
  (ryo-modal-key "!" 'ysd-llm-generate-code)

#+end_src

** Various Variables
Most of these settings can probably be handled in customize instead of init.el, but I don't yet have a better solution for keeping certain settings across systems

#+begin_src emacs-lisp
  ;; Set default variables
  (setq-default
   cursor-type '(bar . 2)
   line-number-mode t
   column-number-mode t
   mouse-wheel-progressive-speed nil
   truncate-lines t
   show-trailing-whitespace t
   create-lockfiles nil
   auto-save-default nil
   make-backup-files nil
   ring-bell-function 'ignore)

  ;; Set global minor modes
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (show-paren-mode 1)

  ;; Set fullscreen
  ;; TODO: make fullscreen startup a 'customize' option
  (add-to-list 'default-frame-alist '(internal-border-width . 24))
  (add-to-list 'default-frame-alist '(alpha-background . 70))
#+end_src

** Custom.el
Variables set using =customize= will be read from the "custom.el" file, which is ignored by git. This allows user-set variables to be machine local.

#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (if (file-exists-p custom-file) (load custom-file))
#+end_src


